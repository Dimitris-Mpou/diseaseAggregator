Προγραμματισμός Συστήματος - Άσκηση 2
Δημήτρης Μπούσουλας 1115201500106

		DiseaseAggragetor:

-Λογικη
Ο DiseaseAggragetor δημιουργεί 2 pipes για κάθε worker (ένα write κι ένα read) 
στη συνέχεια κάνει fork numWorker workers και καλεί την exec. Τους στλενει τις 
χώρες που τους αναλογούν κι αυτοί διαβάζουν τα αρχεία τους κι επιστρέφουν summary
statistics τα οποία ο DiseaseAggragetor εμφανίζει χωρίς να αποθηκεύσει. Εκεί μπαίνουν
όλοι σε ένα loop που περιμένουν είτε κάποιο signal είτε εντολές. Ο DiseaseAggragetor
διαβάζει απ' το πληκτρολόγιο αναγνωρίζει την εντολή και την προωθεί κωδικοποιημένη
σε όποιον worker αντιστοιχεί. Έπειτα διαβάζει τα αποτελέσματα που του επιστράφηκαν
και τα εμφανίζει. Αν δοθεί κάποιο signal τα proccesses πράττουν ανάλογα. Ο κώδικας
του DiseaseAggragetor είναι στο main.c, και των workers στο worker.c 

-Δομές Δεδομένων:
Για τις δομές χρησιμοποίησα ό,τι είχα φτιαξει στα πλαίσια της 1ης εργασίας. Η
μόνη αλλαγή ήταν στα AVL Trees όπου επέλεξα στην ισότητα η εγγραφή να μην εισάγεται
στο αριστέρο node αλλά να δημιουργείται μία λίστα υπερχείλησης. Ο κώδικας των
παραπάνω βρίσκεται στα αρχεία: hashtables.c avlTree.c heap.c

input: 
Στο input ακολούθησα την ίδια λογική με την 1η εργασία αλλά προσαρμοσμένη στα 
δεδομένα της 2ης. Σε περίπτωση που έρθει εγγραφή με προγενέστερο exit τότε την 
αγνοεί χωρις να εμφανίσει κάτι. Error εμφανίζει στην περίπτωση που έρθει το ίδιο
RecordID ξανά (στον ίδιο worker καθώς κανένας δεν έχει πρόσβαση στις εγγραφές 
άλλου worker.) Επίσης δημιούργησα την update η οποία διαβάζει ένα ήδη εισαγμένο
αρχείο και προσθέτει όποια νέα έγκυρη εγγραφή βρει.

CountStats:
Αυτή η συνάρτηση καλείται όταν ένας worker διαβάσει τα αρχεία του (εκτός των 
περιπτώσεων που ο worker δημιουργήθηκε για να αντικαταστήσει έναν άλλον που τελείωσε
πρόωρα.) Ανατρέχει τις δομές κι επιστρέφει στον DiseaseAggragetor τα Summary
Statistics.

queries:
Για να γίνει πιο ευανάγνωστος ο κώδικας οι workers όταν τους έρθει ένα query 
καλούν την αντιστοίχη συνάρτηση ώστε να ανατρέξει τις δομές και να γράψει στον
DiseaseAggragetor τα αποτελέσματα. (Αντίθετα με την προηγούμενη εργασία που η
αναζήτηση γινόταν στην main)

protocol (μέριμνα για bufferSize) :
Πρόκειται για τις 2 συναρτήσεις που αναλαμβάνουν τα reads και writes ώστε να
λειτουργεί το πρόγραμμα ανεξαρτήτου bufferSize. Για να αναγνωρίζουν ότι είναι το
τέλος του μηνύματος χρησιμοποιώ τον χαρακτήρα '~'. Η writeProtocol σπάει ένα μήνυμα
σε κομμάτια μεγέθους bufferSize. Στο τελευταίο κομμάτι βάζει στο τέλος τον χαρακτήρα
'~'. Η readProtocol διαβάζει ένα μήνυμα και το κάνει concatanate σε ένα string μέχρι
να διαβάσει τον τελειωτικό χαρακτήρα. Αν το μήνυμα είναι μικρότερο από bufferSize-1
η readProtocol δεν το τεμαχίζει απλά του προσθέτει τον τελειωτικό χαρακτήρα.
Αυτό το πρωτόκολλο απαιτεί bufferSize >= 3 !

Select:
Γίνεται χρήση της select όπου ο DiseaseAggragetor περιμένει παραπάνω από ένας worker
να του επίσρεψουν αποτελέσματα ώστε να μην τον καθυστερούν αργοί workers. (Δηλαδή
στα queries που δεν έχουν όρισμα χωράς αλλά και στα summary statistics.) Επίσης η
select χρησιμοποείται στις while των DiseaseAggragetor και workers. Στην αρχή της
while του DiseaseAggragetor καλείται η select ώστε να ελέγχει αν ο χρήστης έγραψε
κάποια εντολή. Ανά ένα δευτερόλεπτο κανει timeout κι ελέγχει αν κάποιο signal του
άλλαξε κάποιο flag ώστε να κάνει την αντίστοιχη ενέργεια. Το ίδιο κάνουν και οι 
workers βάζοντας την select να ελέγχει αν ο DiseaseAggragetor έγραψε κάτι στο pipe.

signals:
Αν ο DiseaseAggragetor λάβει SIGINT/SIGQUIT στέλνει SIGKILL σε όλους τους workers
οι οποίοι τερματίζουν επί τόπου και στην συνέχεια αποδεσμεύει ότι του μένει (pipes
και μεταβλητές) και δημιουργεί το log_file και τερματίζει. Το ίδιο ακριβώς θα κάνει
και στην περίπτωση που ο χρήστης δώσει την εντολή /exit.
Αν κάποιος worker λάβει SIGINT/SIGQUIT απελευθερώνει τις δομές του δημιουργεί το
log_file και τερματίζει.
Αν ένας worker λάβει SIGUSR1 καλεί την update ώστε να ενημερωθούν οι δομές του με
πιθανή νέα εγγραφή.
Αν ο DiseaseAggragetor λάβει SIGCHLD έχει 2 πιθανές εκδοχές. Στην περίπτωση που το
SIGCHLD ήρθε έπειτα από SIGKILL που έστειλε ο ίδιος η global flag pid θα έχει την
τιμή -2 και ο DiseaseAggragetor θα το αγνοήσει. Αν όταν έρθει το σήμα η pid έχει
άλλη τιμή (συγκεκριμένα -1 ή το pid κάποιου worker που τερμάτισε νωρίτερα) τότε
κάποιος worker τερμάτισε πρόωρα και ο singal handler του DiseaseAggragetor θα 
καλέσει την wait ώστε να θέσει το pid στο proccess id του  worker που τερμάτισε
ώστε εν τέλη να τον αντικαταστήσει.
Συνεπώς όποτε και να σταλεί το signal το πρόγραμμα θα ολοκληρώσει την εργασία που
έκανε και θα εκτελέσει την "ενέργεια" για το σήμα αέμσως μετά.

Πρωτόκολλα επικοινωνίας μέσω pipes:
Προφανώς η όλοι επικοινωνία των workers και DiseaseAggragetor μέσω named pipes 
ακολουθεί πρωτόκολλα επικοινωνίας τα οποία γνωρίζουν και οι 2 άκρες. Για παράδειγμα
ο DiseaseAggragetor καταλαβαίνει ότι ένας worker τελείωσε να του στέλνει symmary
statistics όταν ενώ περίμενε όνομα χώρας του στάλθηκε χαρακτήρτας e.

Compile:
"make", για να φτιαχτεί το βασικό εκτελέσιμο
"make worker", για να φτιαχτεί το εκτελέσιμο worker που καλεί η exec για τους workers



		create_infiles.sh:
Αρχικά ελέγχει τις παραμέτρους και εμφανίζει το αντίστοιχο μήνυμα. Στην συνέχεια
διαβάζει κι αποθηκεύει σε πίνακες τις χώρες και τις ασθένειες. Έπειτα δημιουργεί
τα subdirectories των χωρών και κάνει touch τα αρχεία ημερομηνιών χωρίς να φτιάχνει
διπλότυπα ημερομηνιών στις ίδιες χώρες. Για κάθε αρχείο που έκανε touch δημιουργεί
$5 εγγραφές. Στο 1ο θα είναι όλες ENTER ενώ στα υπόλοιπα θα είναι 50% ENTER, 50%
EXIT. Αυτό to κάνει ώστε να μην γίνονται οι περισσότερες εγγραφές την ίδια
ημερομηνία enter και exit. Όταν μία εγγραφή γίνει enter αποθηκεύτεαι σε έναν πίνακα
ενώ όταν επιλεχτεί μία εγγαρφή να γίνει exit αντιγράφεται μία απ'τις αποθηκευμένες
που είχαν γίνει enter. Αυτό έχει ως αποτελέσμα να είναι πιθανό μία exit να είναι
προγενέστερη της enter (διότι τα αρχεία ημερομηνιών δεν είανι με αύξουσα σειρά) 
αλλά να μην έρθει ποτέ εγγραφή exit που δεν έγινε ποτέ enter.   
Ο χρόνος εκτέλεσης είναι περίπου:
Ακαριαίως για 250 εγγαρφές
12 δευτερόλεπτα για 1.500 εγγραφές
2 λεπτά για 15.000 εγγαρφές


